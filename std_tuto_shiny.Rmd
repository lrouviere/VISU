---
title: "Visualisation intéractive et Shiny"
output:
  html_notebook:
    css: ~/Dropbox/FICHIERS_STYLE/styles.css
    df_print: paged
    toc: yes
    toc_float: yes
#  html_document: default
#  runtime: shiny
#editor_options: 
#  chunk_output_type: inline
---


Tout comme **leaflet** pour les cartes, il existe de nombreux outils **R** dédiés à la visualisation interactive. Nous en présentons quelques uns dans cette partie.

# Représentations classiques avec `rAmCharts` et `plotly`

Le package [rAmCharts](https://datastorm-open.github.io/introduction_ramcharts/) est très utilie pour donner un carcatère interactif à des représentations graphiques standards (nuages de points, séries temporelles, histogrammes...). Ce package a été fait dans l'esprit d'utiliser les fonctions graphiques de **R** en utilisant le préfixe **am**. La syntaxe est très proche de celle des fonctions graphiques standards. On a par exemple :



```{r message=FALSE, warning=FALSE}
library(rAmCharts)
amHist(iris$Petal.Length)
amPlot(iris, col = colnames(iris)[1:2], type = c("l", "st"), 
       zoom = TRUE, legend = TRUE)
amBoxplot(iris)
boxplot(iris)
```


[plotly](https://plot.ly/r/) permet de faire des choses semblables avec avec une syntaxe specifique. Les commandes **plotly** se décomposent essentiellement en 3 parties :

* le type de représentation graphique (**plot_ly**}) ;
* les ajouts que l'on souhaite effectuer (**add_trace**) ;
* la gestion de la fenêtre graphique (axes, titres...) (**layout**).

On trouvera un descriptif complet de ces 3 composantes [ici](https://plot.ly/r/reference/). On peut par exemple tracer un nuage de points avec une droite de régression avec

```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(plotly)
n <- 100
X <- runif(n,-5,5)
Y <- 2+3*X+rnorm(n,0,1)
D <- data.frame(X,Y)
model <- lm(Y~X,data=D)
D %>% plot_ly(x=~X,y=~Y) %>% add_markers(type="scatter",mode="markers",marker=list(color="red"),name="Nuage") %>%
  add_trace(y=fitted(model),type="scatter",mode='lines',name="Régression",line=list(color="blue")) %>% 
  layout(title="Régression",xaxis=list(title="abscisse"),yaxis=list(title="ordonnées"))
```

Contrairement à **ggplot**, **plotly** permet de faire de la 3D. Par exemple

```{r}
plot_ly(z = volcano, type = "surface")
plot_ly(z = volcano, type = "contour")
```


De plus, la fonction **ggplotly** permet de convertir un objet **ggplot** en **plotly** :
```{r}
p <- ggplot(iris)+aes(x=Species,y=Sepal.Length)+geom_boxplot()+theme_classic()
ggplotly(p)
```


# Réseaux avec visNetwork

De nombreuses données peuvent être visualisées à l'aide d'un réseau, notamment lorsqu'il s'agit de représenter des connections entre individus. Un individu est alors représentés par un noeud et les individus connectés sont reliés par des arrêtes. Le package (igraph)[http://kateto.net/networks-r-igraph] propose une visualisation statique d'un réseau. Pour donner un caractère dynamique à cetype de représentation, on pourra utiliser le package [visNetwork](https://datastorm-open.github.io/visNetwork/interaction.html). Une représentation standard **visNetwork** s'effectue en spécifiant les noeuds et connections d'un graphe :

```{r}
nodes <- data.frame(id = 1:15, label = paste("Id", 1:15),group=sample(LETTERS[1:3], 15, replace = TRUE))
edges <- data.frame(from = trunc(runif(15)*(15-1))+1,to = trunc(runif(15)*(15-1))+1)
library(visNetwork)
data.frame(nodes=nodes,edges=edges)
visNetwork(nodes,edges)
visNetwork(nodes, edges) %>% visOptions(highlightNearest = TRUE)
visNetwork(nodes, edges) %>% visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)
visNetwork(nodes, edges) %>% visOptions(selectedBy = "group")
```


### Exercice 1

Pour le jeu de données **iris** on effectuera les graphes suivants en **rAmCharts** et **plotly**.

1. Nuage de points représentant les longeurs et largeurs de Sépales. On utilisera une couleur différente en fonction de l'espèce.


2. Boxplot permettant de visualiser la distribution de la variable **Petal.Length** en fonction de l'espèce.



### Exercice 2

Le fichier **temperat.txt** contient les températures moyennes mensuelles de 15 villes, ainsi que leurs géolocalisations.

1. Importer le fichier


2. Représenter les villes sur une carte de France.



3. A l'aide de la fonction **heatmap**, visualiser des groupes de villes qui comportent des similitudes en terme de températures mensuelles.


4. Effectuer une classification ascendante hiérarchique pour créer 3 ou 4 clusters de villes. On pourra utiliser **hclust**.


5. Visualiser les groupes créés sur une carte de France.


6. Visualiser les groupes créés à l'aide d'un réseau effectué avec **visNetwork**.



# Dashboard

Un tableau de bord permet de visualiser "facilement" et "rapidement" divers graphes et/ou résumés statistiques en lien avec une problématique donnée. Sur **R** le package **flexdashboard** permet de construire de tels tableaux de bord. On trouvera un descriptif précis de ce package à cette url : [https://rmarkdown.rstudio.com/flexdashboard/](https://rmarkdown.rstudio.com/flexdashboard/).

### Exercice 3

On considère le jeu de données **ozone.txt**

1. Représenter le nuage de points **maxO3 vs T12** en ajoutant un lisseur. On fera les graphes en **ggplot** et **rAmCharts** et **plotly** (en utilisant **ggplotly** par exemple).



2. Même question pour l'histogramme de la variable **maxO3**.


3. Construire le modèle linéaire permettant d'expliquer **maxO3** par les autres variables. Calculer les résidus studentisés (**rstudent**) et visualiser ces résidus en fonction de la variable **maxO3**. Là encore on pourra ajouter un lisseur sur le graphe.



4. Construire un **dashboard** permettant de visualiser sur une page : 

  * le jeu de données (on pourra utiliser la fonction **datatable** du package **DT**)
  * L'histogramme et le nuage de points calculés dans les questions 1 et 2.
  
On utilisera les menus : **File -> Rmardown -> From Template -> Flex Dashboard**.

5. Ajouter un onglet permettant de visualiser les coefficients du modèle linéaire ainsi que le graphe des résidus effectués à la questions 3.

6. Ajouter un nouvel onglet permettant de choisir les variables explicatives dans le modèle linéaire. Pour ce faire, il faudra utiliser des commandes **Shiny**, par exemple

```{r,eval=FALSE}
checkboxGroupInput("variable",
                   label="Choisir la variable",
                   choices=names(df)[-1],
                   selected=list("T9"))
```

Pour les variables choisies, on affichera dans ce nouvel onglet les coefficients du modèle linéaire ainsi que le graphe des résidus studentisés.

7. On pourra terminer en essayant d'obtenir un **dashboard** proche de (ou mieux que) celui présenté à l'url [https://lrouviere.shinyapps.io/dashboard/](https://lrouviere.shinyapps.io/dashboard/)

# R shiny



### Exercice 4

On considère le jeu de données *SAheart* du package **bestglm**.

1. A l'aide du package **rAmCharts**, représenter les histogrammes des variables quantitatives du jeu de données ainsi que les boxplot de ces variables en fonction de la variable **chd**.



2. Créer une application shiny qui permette de 

  * choisir une variable parmi les variables quantitatives du jeu de données. On pourra utiliser **radioButtons** avec l'argument

```{r, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
choices=names(SAheart)[sapply(SAheart,class)=="numeric"]
```

  * visualiser l'histogramme, puis le boxplot en fonction de *chd* de la variable sélectionnée. Ces graphiques devront être faits avec **rAmCharts**. On pourra utiliser **amChartsOutput**.

L'application demandée pourra être proche de celle disponible à cette url [https://lrouviere.shinyapps.io/desc_app/](https://lrouviere.shinyapps.io/desc_app/)



### Exercice 5

1. On considère le même jeu de données. On veut expliquer la variable **chd**. Créer une application shiny qui permette de choisir entre une **lda**, une **régression logistique** et une régression logistique où on utilise l'**AIC** ou le **BIC** pour sélectionner les variables. L'application devra afficher le résumé (*summary*) du modèle sélectionné. On pourra utiliser

```{r, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
selectInput("methode","Choisir la méthode",selected=c("Logistique","LDA"),multiple=TRUE,choices = c("Logistique","BIC","AIC","LDA"))
```

et l'application pourra ressembler à [https://lrouviere.shinyapps.io/choix_mod_app/](https://lrouviere.shinyapps.io/choix_mod_app/)



2. Expliquer la fonction **trace_roc** qui se trouve sur la page web du cours.



3. Ajouter à l'application un slider qui permette de choisir la taille de l'échantillon d'apprentissage sur lequel on ajuste le modèle. On pourra utiliser

```{r, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
sliderInput(inputId="napp",
            label="Taille de l'échantillon d'apprentissage",
            min = 2,max = nrow(SAheart),
            value =round(nrow(SAheart)/2))
```

4. Rappeler l'utilité de la fonction **reactive**. 


5. Ajouter la courbe ROC du (ou des) modèle(s) choisi(s). Cette courbe devra se mettre à jour lorsqu'on modifie le modèle et la taille de l'échantillon d'apprentissage.

On pourra s'inspirer de l'application [https://lrouviere.shinyapps.io/roc_app/](https://lrouviere.shinyapps.io/roc_app/)


### Exercice 6


On pourra aussi essayer de réaliser une application pour visualiser les stations velib à Rennes comme celle ci [https://lrouviere.shinyapps.io/velib/](https://lrouviere.shinyapps.io/velib/). On récupérera les données sur le site de Rennes métropole : [https://data.rennesmetropole.fr/explore/dataset/etat-des-stations-le-velo-star-en-temps-reel/export/](https://data.rennesmetropole.fr/explore/dataset/etat-des-stations-le-velo-star-en-temps-reel/export/)
